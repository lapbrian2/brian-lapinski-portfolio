import type { PromptNode, TechniqueCategory } from '~/types/artwork'

/**
 * Ossuary Fork Workflow ‚Äî generate editable prompt templates from artwork schemas
 *
 * Takes the raw prompt + technique nodes for an artwork and produces a structured,
 * editable template the user can paste into Midjourney / other AI tools.
 */

interface ForkOptions {
  title: string
  rawPrompt?: string | null
  mjVersion?: string | null
  promptNodes?: PromptNode[]
}

// Category display metadata
const categoryMeta: Record<TechniqueCategory, { label: string; icon: string }> = {
  lighting: { label: 'Lighting', icon: 'üí°' },
  camera: { label: 'Camera', icon: 'üì∑' },
  style: { label: 'Style', icon: 'üé®' },
  mood: { label: 'Mood', icon: 'üåô' },
  composition: { label: 'Composition', icon: 'üìê' },
  material: { label: 'Material', icon: 'üß±' },
  color: { label: 'Color', icon: 'üé®' },
  post: { label: 'Post-Processing', icon: '‚ú®' },
}

export function usePromptFork() {
  const copied = ref(false)
  const copyTimeoutId = ref<ReturnType<typeof setTimeout> | null>(null)

  /**
   * Generate a structured prompt template from an artwork's schema
   */
  function generateTemplate(options: ForkOptions): string {
    const { title, rawPrompt, mjVersion, promptNodes } = options
    const lines: string[] = []

    // Header
    lines.push(`// Forked from: "${title}"`)
    lines.push(`// Generated by Ossuary ‚Äî lapinski.art`)
    lines.push('')

    // Raw prompt as the starting point
    if (rawPrompt) {
      lines.push('// === BASE PROMPT ===')
      lines.push('// Edit the subject/scene below, keep the technique parameters')
      lines.push('')
      lines.push(rawPrompt)
      lines.push('')
    }

    // Technique breakdown by category
    if (promptNodes?.length) {
      lines.push('// === TECHNIQUE BREAKDOWN ===')
      lines.push('// Swap or remove techniques to create your variation')
      lines.push('')

      // Group by category
      const grouped = new Map<TechniqueCategory, PromptNode[]>()
      for (const node of promptNodes) {
        if (!grouped.has(node.category)) grouped.set(node.category, [])
        grouped.get(node.category)!.push(node)
      }

      for (const [cat, nodes] of grouped) {
        const meta = categoryMeta[cat]
        lines.push(`// ${meta.icon} ${meta.label}`)
        for (const node of nodes) {
          lines.push(`//   ‚Üí ${node.name}${node.description ? ` ‚Äî ${node.description}` : ''}`)
        }
        lines.push('')
      }
    }

    // Version tag
    if (mjVersion) {
      lines.push(`// Version: ${mjVersion}`)
    }

    return lines.join('\n')
  }

  /**
   * Generate a minimal "quick fork" ‚Äî just the prompt with technique tags as comments
   */
  function generateQuickFork(options: ForkOptions): string {
    const { rawPrompt, promptNodes, mjVersion } = options

    if (!rawPrompt) return '// No prompt data available for this artwork'

    const lines: string[] = []
    lines.push(rawPrompt)

    if (promptNodes?.length) {
      lines.push('')
      lines.push(`// Techniques: ${promptNodes.map((n) => n.name).join(', ')}`)
    }

    if (mjVersion) {
      lines.push(`// ${mjVersion}`)
    }

    return lines.join('\n')
  }

  /**
   * Copy text to clipboard with visual feedback
   */
  async function copyToClipboard(text: string): Promise<boolean> {
    try {
      await navigator.clipboard.writeText(text)
      copied.value = true

      // Clear previous timeout
      if (copyTimeoutId.value) clearTimeout(copyTimeoutId.value)
      copyTimeoutId.value = setTimeout(() => {
        copied.value = false
      }, 2500)

      return true
    } catch {
      // Fallback for older browsers
      try {
        const textarea = document.createElement('textarea')
        textarea.value = text
        textarea.style.position = 'fixed'
        textarea.style.opacity = '0'
        document.body.appendChild(textarea)
        textarea.select()
        document.execCommand('copy')
        document.body.removeChild(textarea)

        copied.value = true
        if (copyTimeoutId.value) clearTimeout(copyTimeoutId.value)
        copyTimeoutId.value = setTimeout(() => {
          copied.value = false
        }, 2500)

        return true
      } catch {
        return false
      }
    }
  }

  /**
   * Fork an artwork ‚Äî generate template and copy to clipboard
   */
  async function fork(options: ForkOptions): Promise<boolean> {
    const template = generateTemplate(options)
    return copyToClipboard(template)
  }

  /**
   * Quick fork ‚Äî copy just the raw prompt with technique tags
   */
  async function quickFork(options: ForkOptions): Promise<boolean> {
    const text = generateQuickFork(options)
    return copyToClipboard(text)
  }

  return {
    copied,
    generateTemplate,
    generateQuickFork,
    copyToClipboard,
    fork,
    quickFork,
  }
}
